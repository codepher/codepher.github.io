{"title":"dtls config","uid":"3346a6d7769e51eb6fa14e4e3e7e03e2","slug":"notes/dtls config","date":"2021-05-05T16:00:00.000Z","updated":"2021-05-06T02:23:27.939Z","comments":true,"path":"api/articles/notes/dtls config.json","keywords":null,"cover":null,"content":"<pre><code class=\"golang\">// Config is used to configure a DTLS client or server.\n// After a Config is passed to a DTLS function it must not be modified.\ntype Config struct {\n    // Certificates contains certificate chain to present to the other side of the connection.\n    // Server MUST set this if PSK is non-nil\n    // client SHOULD sets this so CertificateRequests can be handled if PSK is non-nil\n    // 证书\n    Certificates []tls.Certificate\n\n    // CipherSuites is a list of supported cipher suites.\n    // If CipherSuites is nil, a default list is used\n    // 加密算法 加密字典\n    CipherSuites []CipherSuiteID\n\n    // CustomCipherSuites is a list of CipherSuites that can be\n    // provided by the user. This allow users to user Ciphers that are reserved\n    // for private usage.\n    // \n    CustomCipherSuites func() []CipherSuite\n\n    // SignatureSchemes contains the signature and hash schemes that the peer requests to verify.\n    SignatureSchemes []tls.SignatureScheme\n\n    // SRTPProtectionProfiles are the supported protection profiles\n    // Clients will send this via use_srtp and assert that the server properly responds\n    // Servers will assert that clients send one of these profiles and will respond as needed\n    SRTPProtectionProfiles []SRTPProtectionProfile\n\n    // ClientAuth determines the server&#39;s policy for\n    // TLS Client Authentication. The default is NoClientCert.\n    ClientAuth ClientAuthType\n\n    // RequireExtendedMasterSecret determines if the &quot;Extended Master Secret&quot; extension\n    // should be disabled, requested, or required (default requested).\n    // 加密扩展类型 \n    ExtendedMasterSecret ExtendedMasterSecretType\n\n    // FlightInterval controls how often we send outbound handshake messages\n    // defaults to time.Second\n    FlightInterval time.Duration\n\n    // PSK sets the pre-shared key used by this DTLS connection\n    // If PSK is non-nil only PSK CipherSuites will be used\n    PSK             PSKCallback\n    PSKIdentityHint []byte\n\n    // InsecureSkipVerify controls whether a client verifies the\n    // server&#39;s certificate chain and host name.\n    // If InsecureSkipVerify is true, TLS accepts any certificate\n    // presented by the server and any host name in that certificate.\n    // In this mode, TLS is susceptible to man-in-the-middle attacks.\n    // This should be used only for testing.\n    InsecureSkipVerify bool\n\n    // InsecureHashes allows the use of hashing algorithms that are known\n    // to be vulnerable.\n    InsecureHashes bool\n\n    // VerifyPeerCertificate, if not nil, is called after normal\n    // certificate verification by either a client or server. It\n    // receives the certificate provided by the peer and also a flag\n    // that tells if normal verification has succeedded. If it returns a\n    // non-nil error, the handshake is aborted and that error results.\n    //\n    // If normal verification fails then the handshake will abort before\n    // considering this callback. If normal verification is disabled by\n    // setting InsecureSkipVerify, or (for a server) when ClientAuth is\n    // RequestClientCert or RequireAnyClientCert, then this callback will\n    // be considered but the verifiedChains will always be nil.\n    VerifyPeerCertificate func(rawCerts [][]byte, verifiedChains [][]*x509.Certificate) error\n\n    // RootCAs defines the set of root certificate authorities\n    // that one peer uses when verifying the other peer&#39;s certificates.\n    // If RootCAs is nil, TLS uses the host&#39;s root CA set.\n    // ca根证书\n    RootCAs *x509.CertPool\n\n    // ClientCAs defines the set of root certificate authorities\n    // that servers use if required to verify a client certificate\n    // by the policy in ClientAuth.\n    ClientCAs *x509.CertPool\n\n    // ServerName is used to verify the hostname on the returned\n    // certificates unless InsecureSkipVerify is given.\n    ServerName string\n\n    LoggerFactory logging.LoggerFactory\n\n    // ConnectContextMaker is a function to make a context used in Dial(),\n    // Client(), Server(), and Accept(). If nil, the default ConnectContextMaker\n    // is used. It can be implemented as following.\n    //\n    //     func ConnectContextMaker() (context.Context, func()) {\n    //         return context.WithTimeout(context.Background(), 30*time.Second)\n    //     }\n    ConnectContextMaker func() (context.Context, func())\n\n    // MTU is the length at which handshake messages will be fragmented to\n    // fit within the maximum transmission unit (default is 1200 bytes)\n    MTU int\n\n    // ReplayProtectionWindow is the size of the replay attack protection window.\n    // Duplication of the sequence number is checked in this window size.\n    // Packet with sequence number older than this value compared to the latest\n    // accepted packet will be discarded. (default is 64)\n    ReplayProtectionWindow int\n\n    // KeyLogWriter optionally specifies a destination for TLS master secrets\n    // in NSS key log format that can be used to allow external programs\n    // such as Wireshark to decrypt TLS connections.\n    // See https://developer.mozilla.org/en-US/docs/Mozilla/Projects/NSS/Key_Log_Format.\n    // Use of KeyLogWriter compromises security and should only be\n    // used for debugging.\n    KeyLogWriter io.Writer\n}\n</code></pre>\n","text":"// Config is used to configure a DTLS client or server. // After a Config is passed to a DTLS function it must not be modified. type Config ...","link":"","photos":[],"count_time":{"symbolsCount":"5.2k","symbolsTime":"5 mins."},"categories":[],"tags":[],"toc":"","author":{"name":"codepher","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"linux 慢网速","uid":"22f3a2b9f9860ff96fb05d7f1cc9a954","slug":"notes/Linux 慢网速","date":"2021-06-11T16:00:00.000Z","updated":"2021-06-12T02:06:43.731Z","comments":true,"path":"api/articles/notes/Linux 慢网速.json","keywords":null,"cover":null,"text":"sudo tc qdisc add dev ens33 root netem delay 500ms #设置500ms的延迟 sudo tc qdisc add dev ens33 root netem loss 50% #设置50%的丢包率 sudo tc qdisc add ...","link":"","photos":[],"count_time":{"symbolsCount":232,"symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"codepher","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"golang grpc","uid":"07723b3eccecbafa4111980c975f8316","slug":"notes/golang/golang grpc","date":"2021-04-21T16:00:00.000Z","updated":"2021-04-22T08:53:48.928Z","comments":true,"path":"api/articles/notes/golang/golang grpc.json","keywords":null,"cover":null,"text":"安装1.从github上下载protobuf3 protobuf3下载地址 有很多语言版本的，mac下选择第一个。 2.下载下来后解压压缩包，并进入目录 cd protobuf-3.7.0/3.设置编译目录 ./configure --prefix=/usr/local/prot...","link":"","photos":[],"count_time":{"symbolsCount":713,"symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"codepher","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}