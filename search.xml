<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[LeetCode 669 修剪二叉搜索树]]></title>
    <url>%2Fpost%2F39a05a73cee7274b5d07ab816d4af700%2F</url>
    <content type="text"><![CDATA[#669 修剪二叉搜索树题目描述 给定一个二叉搜索树，同时给定最小边界L 和最大边界 R。通过修剪二叉搜索树，使得所有节点的值在[L, R]中 (R&gt;=L) 。你可能需要改变树的根节点，所以结果应当返回修剪好的二叉搜索树的新的根节点。 拓展 二叉搜索树的性质： 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值 代码实现1234567891011121314151617181920212223242526272829303132/** * Definition for a binary tree node. * class TreeNode &#123; * public $val = null; * public $left = null; * public $right = null; * function __construct($value) &#123; $this-&gt;val = $value; &#125; * &#125; */class Solution &#123; /** * @param TreeNode $root * @param Integer $L * @param Integer $R * @return TreeNode */ function trimBST($root, $L, $R) &#123; if($root-&gt;val === null)&#123; return null; &#125; if($root-&gt;val &gt; $R)&#123; return $this-&gt;trimBST($root-&gt;left,$L,$R); &#125; if($root-&gt;val &lt; $L)&#123; return $this-&gt;trimBST($root-&gt;right,$L,$R); &#125; $root-&gt;left = $this-&gt;trimBST($root-&gt;left,$L,$R); $root-&gt;right = $this-&gt;trimBST($root-&gt;right,$L,$R); return $root; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 965 单值二叉树]]></title>
    <url>%2Fpost%2Fd0ad05be6d45fad86cbf2deb91d4493c%2F</url>
    <content type="text"><![CDATA[#965 单值二叉树题目描述 如果二叉树每个节点都具有相同的值，那么该二叉树就是单值二叉树。只有给定的树是单值二叉树时，才返回 true；否则返回 false。 代码实现PHP12345678910111213141516171819202122232425262728293031323334&lt;?php/** * 如果二叉树每个节点都具有相同的值，那么该二叉树就是单值二叉树。 * 只有给定的树是单值二叉树时，才返回 true；否则返回 false。 * Definition for a binary tree node. * class TreeNode &#123; * public $val = null; * public $left = null; * public $right = null; * function __construct($value) &#123; $this-&gt;val = $value; &#125; * &#125; */class Solution &#123; /** * @param TreeNode $root * @return Boolean */ function isUnivalTree($root) &#123; if($root == null)&#123; return true; &#125; if(($root-&gt;left !== null &amp;&amp; $root-&gt;val != $root-&gt;left-&gt;val) ||($root-&gt;right !== null &amp;&amp; $root-&gt;val != $root-&gt;right-&gt;val))&#123; return false; &#125; if($this-&gt;isUnivalTree($root-&gt;left) === false|| $this-&gt;isUnivalTree($root-&gt;right) === false)&#123; return false; &#125; return true; &#125;&#125; Golang12345678910111213141516171819202122/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */func isUnivalTree(root *TreeNode) bool &#123; if(root == nil)&#123; return true &#125; if((root.Left != nil &amp;&amp; root.Val != root.Left.Val) || (root.Right != nil &amp;&amp; root.Val != root.Right.Val))&#123; return false &#125; if(isUnivalTree(root.Left) == false || false == isUnivalTree(root.Right))&#123; return false &#125; return true&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOs 中安装Chrome+ChromeDriver]]></title>
    <url>%2Fpost%2Fc0247538c4f3e46df13bd7991ce16b18%2F</url>
    <content type="text"><![CDATA[安装Chrome1.安装Chrome1curl https://intoli.com/install-google-chrome.sh | bash 2.测试浏览器1google-chrome-stable --no-sandbox --headless --disable-gpu --screenshot https://www.baidu.com/ 会保存一张图片在当前路径 安装ChromeDriver查看Chrome版本1google-chrome --version 查找对应的驱动的网址 http://chromedriver.storage.googleapis.com/index.html*下载安装包1wget http://chromedriver.storage.googleapis.com/78.0.3904.70/chromedriver_linux64.zip 解压12345# 没有 unzip 使用 yum 安装即可unzip chromedriver_linux64.zip# 解压完成后可将可执行文件移到bin目录方便后续使用mv chromedriver /usr/bin/]]></content>
  </entry>
  <entry>
    <title><![CDATA[golang 交叉编译]]></title>
    <url>%2Fpost%2Ff6eab270974ee0fbaf611254e9e11416%2F</url>
    <content type="text"><![CDATA[Mac 下编译 Linux 和 Windows 64位可执行程序 12CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build main.goCGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build main.go Linux 下编译 Mac 和 Windows 64位可执行程序 12CGO_ENABLED=0 GOOS=darwin GOARCH=amd64 go build main.goCGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build main.go Windows 下编译 Mac 和 Linux 64位可执行程序 123456789SET CGO_ENABLED=0SET GOOS=darwinSET GOARCH=amd64go build main.goSET CGO_ENABLED=0SET GOOS=linuxSET GOARCH=amd64go build main.go GOOS：目标平台的操作系统（darwin、freebsd、linux、windows）GOARCH：目标平台的体系架构（386、amd64、arm）交叉编译不支持 CGO 所以要禁用它 上面的命令编译 64 位可执行程序，你当然应该也会使用 386 编译 32 位可执行程序]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux screen]]></title>
    <url>%2Fpost%2F180caaa829345bfd949e059951dab6a8%2F</url>
    <content type="text"><![CDATA[screen⌘ Command（或 Cmd）⌘Shift ⇧Option（或 Alt）⌥Control（或 Ctrl）⌃Caps Lock ⇪Fn]]></content>
      <categories>
        <category>Linux</category>
        <category>Linux 软件</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux ls]]></title>
    <url>%2Fpost%2F5f8cb416ad6efe9e46d235a71f3caf21%2F</url>
    <content type="text"><![CDATA[ls 命令 -ls 就能看到在当前目录下所有文件和子目录的列表。 ls 命令选项 选项 长选项 描述 -a –all 列出所有文件，甚至包括文件名以圆点开头的默认会被隐藏的隐藏文件。 -d –directory 通常，如果指定了目录名，ls 命令会列出这个目录中的内容，而不是目录本身。 把这个选项与 -l 选项结合使用，可以看到所指定目录的详细信息，而不是目录中的内容。 -F –classify 这个选项会在每个所列出的名字后面加上一个指示符。例如，如果名字是 目录名，则会加上一个’/‘字符。 -h –human-readable 当以长格式列出时，以人们可读的格式，而不是以字节数来显示文件的大小。 -l - 以长格式显示结果。 -r –reverse 以相反的顺序来显示结果。通常，ls 命令的输出结果按照字母升序排列。 -S - 命令输出结果按照文件大小来排序。 -t - 按照修改时间来排序。 ls -l1234567891011121314151617[root@iZ28jjwy44gZ ~]# ls -l总用量 8976drwxr-xr-x 6 root root 4096 6月 19 07:16 blogdrwxr-xr-x 2 root root 4096 1月 26 2019 certbotdrwxr-xr-x 6 root root 4096 5月 31 12:07 composedrwxr-xr-x 3 root root 4096 1月 30 2019 goproductdrwxr-xr-x 4 root root 4096 1月 26 2019 logsdrwxr-xr-x 5 root root 4096 2月 13 2019 nginxdrwxr-xr-x 9 1001 1001 4096 1月 30 2019 nginx-1.15.8-rw-r--r-- 1 root root 1027862 12月 25 2018 nginx-1.15.8.tar.gzdrwxr-xr-x 18 root root 4096 1月 30 2019 openssl-1.1.0j-rw-r--r-- 1 root root 5411919 11月 20 2018 openssl-1.1.0j.tar.gzdrwxr-xr-x 9 1169 1169 12288 1月 30 2019 pcre-8.42-rw-r--r-- 1 root root 2081413 4月 2 2018 pcre-8.42.tar.gzdrwxr-xr-x 2 root root 4096 6月 24 14:32 phpdrwxr-xr-x 14 501 games 4096 1月 30 2019 zlib-1.2.11-rw-r--r-- 1 root root 607698 1月 16 2017 zlib-1.2.11.tar.gz drwxr-xr-x 6 root root 4096 6月 19 07:16 blog 对于文件的访问权限 文件的硬链接数目 文件所有者的用户名 文件所属用户组的名字 以字节数表示的文件大小 上次修改文件的时间和日期 文件名]]></content>
      <categories>
        <category>Linux</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[go mod]]></title>
    <url>%2Fpost%2Fc91ca214e12a0715ec3ef2e5138df095%2F</url>
    <content type="text"><![CDATA[go mod 命令go mod tidy 拉取缺少的模块，移除不用的模块。 go mod vendor 将依赖复制到vendor下。 go mod download 下载依赖包。 go mod verify 检验依赖。 go mod graph 打印模块依赖图。]]></content>
      <categories>
        <category>golang</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高数一-函数]]></title>
    <url>%2Fpost%2Fd71b019935732176395383a7ddfe8294%2F</url>
    <content type="text"><![CDATA[函数集合定义 具有某种确定性质的对象的全体集合成为一个 集合 组成集合的个别对象成为该集合的 元素 表示 一般用大写 ABC 等表示集合 用小写 abc 等表示集合的元素 不含任何元素的集合叫做空集 用 ∅ 表示 a ∈ A 表示 a 是 A 中的元素 a ∉ A 表示 a 不是 A 中的元素 A = { x | x 具有性质 P(x)} 例：A = { x | x &gt; 0, x ∈ R} 特殊数集 N 自然数集 自然数由0开始，一个接一个，即用数码0，1，2，3，4……所表示的数。 Z 整数集 由全体整数组成的集合叫整数集。它包括全体正整数、全体负整数和零 Q 有理数集 有理数集，即由所有有理数所构成的集合。 有理数集是实数集的子集，即 Q ∈ R 有理数集是一个无穷集，不存在最大值或最小值。 R 实数集 实数集通俗地认为，通常包含所有有理数和无理数的集合就是实数集，通常用大写字母R表示 集合运算 设 A，B 为两个集合 若 ∀x(任意X) ∈ A,必有 x ∈ B。则 A ⊆ B ( A 包含于 B) 若 A ⊆ B， 且 B ⊆ A。则 A = B 并集：A ∪ B = { x | x ∈ A 或 x ∈ B } 交集：A ∩ B = { x | x ∈ A 且 x ∈ B } 子集：子集是一个数学概念：如果集合 A 的任意一个元素都是集合 B 的元素，那么集合 A 称为集合 B 的子集。 符号语言：若 ∀a ∈ A，均有 a ∈ B，则 A ⊆ B 差集：A \ B = { x | x ∈ A 且 x ∉ B} 余集：若 X 为全集或基本集， A 的余集(符号不知道怎么打) = X \ A = { x | x ∈ X 但 x ∉ A} 集合的运算法则 设 A，B，C 为三个集合，则有 交换律:A ∪ B = B ∪ A, A ∩ B = B ∩ A 结合律:(A ∪ B) ∪ C = A ∪ (B ∪ C) (A ∩ B) ∩ C = A ∩ (B ∩ C) 分配率(A ∪ B) ∩ C = (A ∩ C) ∪ (B ∩ C) (A ∩ B) ∪ C = (A ∪ C) ∩ (B ∪ C)]]></content>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[无头浏览器-Chrome]]></title>
    <url>%2Fpost%2F252506abb9ed56ebd68358ab46f79c54%2F</url>
    <content type="text"><![CDATA[简介很久都没有搞Python了，最近想去爬取一个网站，发现网站内容是用js生成的，然后就想到了用无头浏览器去处理，之前了解的都是PhantomJS，但是在网上查阅了一些资料后得知PhantomJS停止维护了，而且新版的selenium好像不支持PhantomJS了，需要使用 Chrome 或者 Firefox。 因为我平时用的浏览器就是 Chrome，最后决定用 Chrome 的无头模式来做。 准备 需要通过pip安装 selenium 模块 提前安装好 Chrome 最后还需要下载一个Chrome的驱动才能使用，下载的时候需要根据本地 Chrome 的版本，下载对应的驱动。 下载完 Chromedriver 后我是把 Chromedriver 这个驱动放到了环境变量里。这样方便写代码调用。 ##]]></content>
  </entry>
</search>
