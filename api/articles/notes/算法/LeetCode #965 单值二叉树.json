{"title":"LeetCode 965 单值二叉树","uid":"3ed9223697ebe2dfa7d4b387cfd110d1","slug":"notes/算法/LeetCode #965 单值二叉树","date":"2019-11-01T16:00:00.000Z","updated":"2021-04-15T17:05:26.463Z","comments":true,"path":"api/articles/notes/算法/LeetCode #965 单值二叉树.json","keywords":null,"cover":null,"content":"<h1 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h1><blockquote>\n<p>如果二叉树每个节点都具有相同的值，那么该二叉树就是单值二叉树。只有给定的树是单值二叉树时，才返回 true；否则返回 false。</p>\n</blockquote>\n<h1 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h1><h2 id=\"PHP\"><a href=\"#PHP\" class=\"headerlink\" title=\"PHP\"></a>PHP</h2><pre><code class=\"php\">&lt;?php\n/**\n * 如果二叉树每个节点都具有相同的值，那么该二叉树就是单值二叉树。\n * 只有给定的树是单值二叉树时，才返回 true；否则返回 false。\n * Definition for a binary tree node.\n * class TreeNode {\n *     public $val = null;\n *     public $left = null;\n *     public $right = null;\n *     function __construct($value) { $this-&gt;val = $value; }\n * }\n */\nclass Solution {\n\n    /**\n     * @param TreeNode $root\n     * @return Boolean\n     */\n    function isUnivalTree($root) {\n        if($root ==  null){\n            return true;\n        }\n\n        if(($root-&gt;left !== null &amp;&amp; $root-&gt;val != $root-&gt;left-&gt;val)\n            ||($root-&gt;right !== null &amp;&amp; $root-&gt;val != $root-&gt;right-&gt;val)){\n            return false;\n        }\n\n        if($this-&gt;isUnivalTree($root-&gt;left) === false|| $this-&gt;isUnivalTree($root-&gt;right) === false){\n            return false;\n        }\n        return true;\n    }\n}</code></pre>\n<h2 id=\"Golang\"><a href=\"#Golang\" class=\"headerlink\" title=\"Golang\"></a>Golang</h2><pre><code class=\"golang\">/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc isUnivalTree(root *TreeNode) bool {\n    if(root == nil){\n        return true\n    }\n\n    if((root.Left != nil &amp;&amp; root.Val != root.Left.Val) || (root.Right != nil &amp;&amp; root.Val != root.Right.Val)){\n        return false\n    }\n\n    if(isUnivalTree(root.Left) == false || false == isUnivalTree(root.Right)){\n        return false\n    }\n    return true\n}</code></pre>\n","text":"题目描述 如果二叉树每个节点都具有相同的值，那么该二叉树就是单值二叉树。只有给定的树是单值二叉树时，才返回 true；否则返回 false。 代码实现PHP&lt;?php /** * 如果二叉树每个节点都具有相同的值，那么该二叉树就是单值二叉树。 * 只有给定的树是单值二叉树时...","link":"","photos":[],"count_time":{"symbolsCount":"1.5k","symbolsTime":"1 mins."},"categories":[{"name":"算法","slug":"算法","count":2,"path":"api/categories/算法.json"},{"name":"LeetCode","slug":"算法/LeetCode","count":2,"path":"api/categories/算法/LeetCode.json"}],"tags":[{"name":"LeetCode","slug":"LeetCode","count":2,"path":"api/tags/LeetCode.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0\"><span class=\"toc-text\">题目描述</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">代码实现</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#PHP\"><span class=\"toc-text\">PHP</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Golang\"><span class=\"toc-text\">Golang</span></a></li></ol></li></ol>","author":{"name":"codepher","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"LeetCode 669 修剪二叉搜索树","uid":"cd2563c48a87d924d7af12868e800dc4","slug":"notes/算法/LeetCode #669 修剪二叉搜索树","date":"2019-11-04T16:00:00.000Z","updated":"2021-04-15T17:05:26.344Z","comments":true,"path":"api/articles/notes/算法/LeetCode #669 修剪二叉搜索树.json","keywords":null,"cover":null,"text":"题目描述 给定一个二叉搜索树，同时给定最小边界L 和最大边界 R。通过修剪二叉搜索树，使得所有节点的值在[L, R]中 (R&gt;=L) 。你可能需要改变树的根节点，所以结果应当返回修剪好的二叉搜索树的新的根节点。 拓展 二叉搜索树的性质： 若它的左子树不空，则左子树上所有结点...","link":"","photos":[],"count_time":{"symbolsCount":"1k","symbolsTime":"1 mins."},"categories":[{"name":"算法","slug":"算法","count":2,"path":"api/categories/算法.json"},{"name":"LeetCode","slug":"算法/LeetCode","count":2,"path":"api/categories/算法/LeetCode.json"}],"tags":[{"name":"LeetCode","slug":"LeetCode","count":2,"path":"api/tags/LeetCode.json"}],"author":{"name":"codepher","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"CentOs 中安装Chrome+ChromeDriver","uid":"606613c3ba561758929d001ca1458370","slug":"notes/CentOs 中安装Chrome+ChromeDriver","date":"2019-10-27T16:00:00.000Z","updated":"2020-02-12T03:34:41.588Z","comments":true,"path":"api/articles/notes/CentOs 中安装Chrome+ChromeDriver.json","keywords":null,"cover":null,"text":"安装Chrome1.安装Chromecurl https://intoli.com/install-google-chrome.sh | bash2.测试浏览器google-chrome-stable --no-sandbox --headless --disable-gpu -...","link":"","photos":[],"count_time":{"symbolsCount":500,"symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"codepher","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}